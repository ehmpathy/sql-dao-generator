// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`defineSqlSchemaControlCodeFilesForDomainObjects should work on the example project 1`] = `
[
  GeneratedCodeFile {
    "content": "import { findById } from './findById';
import { findByUnique } from './findByUnique';
import { findByUuid } from './findByUuid';
import { upsert } from './upsert';

export const carriageDao = {
  findById,
  findByUnique,
  findByUuid,
  upsert,
};",
    "relpath": "carriageDao/index.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { Carriage } from '$PATH_TO_DOMAIN_OBJECT';
import { SqlQueryFindCarriageByIdOutput } from '$PATH_TO_GENERATED_SQL_TYPES';

export const castFromDatabaseObject = (
  dbObject: SqlQueryFindCarriageByIdOutput,
): HasMetadata<Carriage> =>
  new Carriage({
    id: dbObject.id,
    uuid: dbObject.uuid,
    cin: dbObject.cin,
    carries: dbObject.carries as Carriage['carries'],
    capacity: dbObject.capacity,
  }) as HasMetadata<Carriage>;",
    "relpath": "carriageDao/castFromDatabaseObject.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { Carriage } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindCarriageById } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_carriage_by_id
  SELECT
    carriage.id,
    carriage.uuid,
    carriage.cin,
    carriage.carries,
    carriage.capacity
  FROM carriage
  WHERE carriage.id = :id;
\`;

export const findById = async ({
  dbConnection,
  id,
}: {
  dbConnection: DatabaseConnection;
  id: number;
}): Promise<HasMetadata<Carriage> | null> => {
  const results = await sqlQueryFindCarriageById({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      id,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "carriageDao/findById.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { Carriage } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindCarriageByUnique } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_carriage_by_unique
  SELECT
    carriage.id,
    carriage.uuid,
    carriage.cin,
    carriage.carries,
    carriage.capacity
  FROM carriage
  WHERE 1=1
    AND carriage.uuid = :uuid;
\`;

export const findByUnique = async ({
  dbConnection,
  uuid,
}: {
  dbConnection: DatabaseConnection;
  uuid: string;
}): Promise<HasMetadata<Carriage> | null> => {
  const results = await sqlQueryFindCarriageByUnique({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      uuid,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "carriageDao/findByUnique.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { Carriage } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindCarriageByUuid } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_carriage_by_uuid
  SELECT
    carriage.id,
    carriage.uuid,
    carriage.cin,
    carriage.carries,
    carriage.capacity
  FROM carriage
  WHERE carriage.uuid = :uuid;
\`;

export const findByUuid = async ({
  dbConnection,
  uuid,
}: {
  dbConnection: DatabaseConnection;
  uuid: string;
}): Promise<HasMetadata<Carriage> | null> => {
  const results = await sqlQueryFindCarriageByUuid({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      uuid,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "carriageDao/findByUuid.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata, HasUuid } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { Carriage } from '$PATH_TO_DOMAIN_OBJECT';
import { log } from '$PATH_TO_LOG_OBJECT';
import { sqlQueryUpsertCarriage } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';

export const sql = \`
  -- query_name = upsert_carriage
  SELECT
    dgv.id
  FROM upsert_carriage(
    :uuid,
    :cin,
    :carries,
    :capacity
  ) as dgv;
\`;

export const upsert = async ({
  dbConnection,
  carriage,
}: {
  dbConnection: DatabaseConnection;
  carriage: HasUuid<Carriage>;
}): Promise<HasMetadata<Carriage>> => {
  const results = await sqlQueryUpsertCarriage({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      uuid: carriage.uuid,
      cin: carriage.cin,
      carries: carriage.carries,
      capacity: carriage.capacity,
    },
  });
  const { id } = results[0]; // grab the db generated values
  return new Carriage({ ...carriage, id }) as HasMetadata<Carriage>;
};",
    "relpath": "carriageDao/upsert.ts",
  },
  GeneratedCodeFile {
    "content": "import { findById } from './findById';
import { findByUnique } from './findByUnique';
import { upsert } from './upsert';

export const certificateDao = {
  findById,
  findByUnique,
  upsert,
};",
    "relpath": "certificateDao/index.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { Certificate } from '$PATH_TO_DOMAIN_OBJECT';
import { SqlQueryFindCertificateByIdOutput } from '$PATH_TO_GENERATED_SQL_TYPES';

export const castFromDatabaseObject = (
  dbObject: SqlQueryFindCertificateByIdOutput,
): HasMetadata<Certificate> =>
  new Certificate({
    id: dbObject.id,
    type: dbObject.type as Certificate['type'],
    industryId: dbObject.industry_id,
  }) as HasMetadata<Certificate>;",
    "relpath": "certificateDao/castFromDatabaseObject.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { Certificate } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindCertificateById } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_certificate_by_id
  SELECT
    certificate.id,
    certificate.type,
    certificate.industry_id
  FROM certificate
  WHERE certificate.id = :id;
\`;

export const findById = async ({
  dbConnection,
  id,
}: {
  dbConnection: DatabaseConnection;
  id: number;
}): Promise<HasMetadata<Certificate> | null> => {
  const results = await sqlQueryFindCertificateById({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      id,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "certificateDao/findById.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { Certificate } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindCertificateByUnique } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_certificate_by_unique
  SELECT
    certificate.id,
    certificate.type,
    certificate.industry_id
  FROM certificate
  WHERE 1=1
    AND certificate.type = :type
    AND certificate.industry_id = :industryId;
\`;

export const findByUnique = async ({
  dbConnection,
  type,
  industryId,
}: {
  dbConnection: DatabaseConnection;
  type: Certificate['type'];
  industryId: string;
}): Promise<HasMetadata<Certificate> | null> => {
  const results = await sqlQueryFindCertificateByUnique({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      type,
      industryId,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "certificateDao/findByUnique.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { Certificate } from '$PATH_TO_DOMAIN_OBJECT';
import { log } from '$PATH_TO_LOG_OBJECT';
import { sqlQueryUpsertCertificate } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';

export const sql = \`
  -- query_name = upsert_certificate
  SELECT
    dgv.id
  FROM upsert_certificate(
    :type,
    :industryId
  ) as dgv;
\`;

export const upsert = async ({
  dbConnection,
  certificate,
}: {
  dbConnection: DatabaseConnection;
  certificate: Certificate;
}): Promise<HasMetadata<Certificate>> => {
  const results = await sqlQueryUpsertCertificate({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      type: certificate.type,
      industryId: certificate.industryId,
    },
  });
  const { id } = results[0]; // grab the db generated values
  return new Certificate({ ...certificate, id }) as HasMetadata<Certificate>;
};",
    "relpath": "certificateDao/upsert.ts",
  },
  GeneratedCodeFile {
    "content": "import { findById } from './findById';
import { findByUnique } from './findByUnique';
import { findByUuid } from './findByUuid';
import { upsert } from './upsert';

export const trainEngineerDao = {
  findById,
  findByUnique,
  findByUuid,
  upsert,
};",
    "relpath": "trainEngineerDao/index.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { TrainEngineer } from '$PATH_TO_DOMAIN_OBJECT';
import { SqlQueryFindCertificateByIdOutput, SqlQueryFindTrainEngineerByIdOutput } from '$PATH_TO_GENERATED_SQL_TYPES';
import { castFromDatabaseObject as castCertificateFromDatabaseObject } from '../certificateDao/castFromDatabaseObject';

export const castFromDatabaseObject = (
  dbObject: SqlQueryFindTrainEngineerByIdOutput,
): HasMetadata<TrainEngineer> =>
  new TrainEngineer({
    id: dbObject.id,
    uuid: dbObject.uuid,
    socialSecurityNumberHash: dbObject.social_security_number_hash,
    certificates: (dbObject.certificates as SqlQueryFindCertificateByIdOutput[]).map(castCertificateFromDatabaseObject),
    licenseUuids: dbObject.license_uuids as string[],
    name: dbObject.name,
  }) as HasMetadata<TrainEngineer>;",
    "relpath": "trainEngineerDao/castFromDatabaseObject.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { TrainEngineer } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindTrainEngineerById } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_train_engineer_by_id
  SELECT
    train_engineer.id,
    train_engineer.uuid,
    train_engineer.social_security_number_hash,
    (
      SELECT COALESCE(
        json_agg(
          json_build_object(
            'id', certificate.id,
            'type', certificate.type,
            'industry_id', certificate.industry_id
          )
          ORDER BY certificate_ref.array_order_index
        ),
        '[]'::json
      ) AS json_agg
      FROM certificate
      JOIN unnest(train_engineer.certificate_ids) WITH ORDINALITY
        AS certificate_ref (id, array_order_index)
        ON certificate.id = certificate_ref.id
    ) AS certificates,
    train_engineer.license_uuids,
    train_engineer.name
  FROM view_train_engineer_current AS train_engineer
  WHERE train_engineer.id = :id;
\`;

export const findById = async ({
  dbConnection,
  id,
}: {
  dbConnection: DatabaseConnection;
  id: number;
}): Promise<HasMetadata<TrainEngineer> | null> => {
  const results = await sqlQueryFindTrainEngineerById({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      id,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "trainEngineerDao/findById.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { TrainEngineer } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindTrainEngineerByUnique } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_train_engineer_by_unique
  SELECT
    train_engineer.id,
    train_engineer.uuid,
    train_engineer.social_security_number_hash,
    (
      SELECT COALESCE(
        json_agg(
          json_build_object(
            'id', certificate.id,
            'type', certificate.type,
            'industry_id', certificate.industry_id
          )
          ORDER BY certificate_ref.array_order_index
        ),
        '[]'::json
      ) AS json_agg
      FROM certificate
      JOIN unnest(train_engineer.certificate_ids) WITH ORDINALITY
        AS certificate_ref (id, array_order_index)
        ON certificate.id = certificate_ref.id
    ) AS certificates,
    train_engineer.license_uuids,
    train_engineer.name
  FROM view_train_engineer_current AS train_engineer
  WHERE 1=1
    AND train_engineer.social_security_number_hash = :socialSecurityNumberHash;
\`;

export const findByUnique = async ({
  dbConnection,
  socialSecurityNumberHash,
}: {
  dbConnection: DatabaseConnection;
  socialSecurityNumberHash: string;
}): Promise<HasMetadata<TrainEngineer> | null> => {
  const results = await sqlQueryFindTrainEngineerByUnique({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      socialSecurityNumberHash,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "trainEngineerDao/findByUnique.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { TrainEngineer } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindTrainEngineerByUuid } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_train_engineer_by_uuid
  SELECT
    train_engineer.id,
    train_engineer.uuid,
    train_engineer.social_security_number_hash,
    (
      SELECT COALESCE(
        json_agg(
          json_build_object(
            'id', certificate.id,
            'type', certificate.type,
            'industry_id', certificate.industry_id
          )
          ORDER BY certificate_ref.array_order_index
        ),
        '[]'::json
      ) AS json_agg
      FROM certificate
      JOIN unnest(train_engineer.certificate_ids) WITH ORDINALITY
        AS certificate_ref (id, array_order_index)
        ON certificate.id = certificate_ref.id
    ) AS certificates,
    train_engineer.license_uuids,
    train_engineer.name
  FROM view_train_engineer_current AS train_engineer
  WHERE train_engineer.uuid = :uuid;
\`;

export const findByUuid = async ({
  dbConnection,
  uuid,
}: {
  dbConnection: DatabaseConnection;
  uuid: string;
}): Promise<HasMetadata<TrainEngineer> | null> => {
  const results = await sqlQueryFindTrainEngineerByUuid({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      uuid,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "trainEngineerDao/findByUuid.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { TrainEngineer } from '$PATH_TO_DOMAIN_OBJECT';
import { log } from '$PATH_TO_LOG_OBJECT';
import { sqlQueryUpsertTrainEngineer } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { certificateDao } from '../certificateDao';

export const sql = \`
  -- query_name = upsert_train_engineer
  SELECT
    dgv.id, dgv.uuid
  FROM upsert_train_engineer(
    :socialSecurityNumberHash,
    :certificateIds,
    :licenseUuids,
    :name
  ) as dgv;
\`;

export const upsert = async ({
  dbConnection,
  trainEngineer,
}: {
  dbConnection: DatabaseConnection;
  trainEngineer: TrainEngineer;
}): Promise<HasMetadata<TrainEngineer>> => {
  const results = await sqlQueryUpsertTrainEngineer({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      socialSecurityNumberHash: trainEngineer.socialSecurityNumberHash,
      certificateIds: await Promise.all(trainEngineer.certificates.map(async (certificate) => certificate.id ? certificate.id : (await certificateDao.upsert({ dbConnection, certificate })).id)),
      licenseUuids: trainEngineer.licenseUuids,
      name: trainEngineer.name,
    },
  });
  const { id, uuid } = results[0]; // grab the db generated values
  return new TrainEngineer({ ...trainEngineer, id, uuid }) as HasMetadata<TrainEngineer>;
};",
    "relpath": "trainEngineerDao/upsert.ts",
  },
  GeneratedCodeFile {
    "content": "import { findById } from './findById';
import { findByUnique } from './findByUnique';
import { upsert } from './upsert';

export const geocodeDao = {
  findById,
  findByUnique,
  upsert,
};",
    "relpath": "geocodeDao/index.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { Geocode } from '$PATH_TO_DOMAIN_OBJECT';
import { SqlQueryFindGeocodeByIdOutput } from '$PATH_TO_GENERATED_SQL_TYPES';

export const castFromDatabaseObject = (
  dbObject: SqlQueryFindGeocodeByIdOutput,
): HasMetadata<Geocode> =>
  new Geocode({
    id: dbObject.id,
    latitude: dbObject.latitude,
    longitude: dbObject.longitude,
  }) as HasMetadata<Geocode>;",
    "relpath": "geocodeDao/castFromDatabaseObject.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { Geocode } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindGeocodeById } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_geocode_by_id
  SELECT
    geocode.id,
    geocode.latitude,
    geocode.longitude
  FROM geocode
  WHERE geocode.id = :id;
\`;

export const findById = async ({
  dbConnection,
  id,
}: {
  dbConnection: DatabaseConnection;
  id: number;
}): Promise<HasMetadata<Geocode> | null> => {
  const results = await sqlQueryFindGeocodeById({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      id,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "geocodeDao/findById.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { Geocode } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindGeocodeByUnique } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_geocode_by_unique
  SELECT
    geocode.id,
    geocode.latitude,
    geocode.longitude
  FROM geocode
  WHERE 1=1
    AND geocode.latitude = :latitude
    AND geocode.longitude = :longitude;
\`;

export const findByUnique = async ({
  dbConnection,
  latitude,
  longitude,
}: {
  dbConnection: DatabaseConnection;
  latitude: number;
  longitude: number;
}): Promise<HasMetadata<Geocode> | null> => {
  const results = await sqlQueryFindGeocodeByUnique({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      latitude,
      longitude,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "geocodeDao/findByUnique.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { Geocode } from '$PATH_TO_DOMAIN_OBJECT';
import { log } from '$PATH_TO_LOG_OBJECT';
import { sqlQueryUpsertGeocode } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';

export const sql = \`
  -- query_name = upsert_geocode
  SELECT
    dgv.id
  FROM upsert_geocode(
    :latitude,
    :longitude
  ) as dgv;
\`;

export const upsert = async ({
  dbConnection,
  geocode,
}: {
  dbConnection: DatabaseConnection;
  geocode: Geocode;
}): Promise<HasMetadata<Geocode>> => {
  const results = await sqlQueryUpsertGeocode({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      latitude: geocode.latitude,
      longitude: geocode.longitude,
    },
  });
  const { id } = results[0]; // grab the db generated values
  return new Geocode({ ...geocode, id }) as HasMetadata<Geocode>;
};",
    "relpath": "geocodeDao/upsert.ts",
  },
  GeneratedCodeFile {
    "content": "import { findById } from './findById';
import { findByUnique } from './findByUnique';
import { findByUuid } from './findByUuid';
import { upsert } from './upsert';

export const trainDao = {
  findById,
  findByUnique,
  findByUuid,
  upsert,
};",
    "relpath": "trainDao/index.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { Train } from '$PATH_TO_DOMAIN_OBJECT';
import { SqlQueryFindGeocodeByIdOutput, SqlQueryFindTrainByIdOutput } from '$PATH_TO_GENERATED_SQL_TYPES';
import { castFromDatabaseObject as castGeocodeFromDatabaseObject } from '../geocodeDao/castFromDatabaseObject';

export const castFromDatabaseObject = (
  dbObject: SqlQueryFindTrainByIdOutput,
): HasMetadata<Train> =>
  new Train({
    id: dbObject.id,
    uuid: dbObject.uuid,
    homeStationGeocode: castGeocodeFromDatabaseObject(dbObject.home_station_geocode as SqlQueryFindGeocodeByIdOutput),
    combinationId: dbObject.combination_id,
    locomotiveUuids: dbObject.locomotive_uuids as string[],
    carriageUuids: dbObject.carriage_uuids as string[],
    engineerUuids: dbObject.engineer_uuids as string[],
    leadEngineerUuid: dbObject.lead_engineer_uuid,
    status: dbObject.status as Train['status'],
  }) as HasMetadata<Train>;",
    "relpath": "trainDao/castFromDatabaseObject.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { Train } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindTrainById } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_train_by_id
  SELECT
    train.id,
    train.uuid,
    (
      SELECT json_build_object(
        'id', geocode.id,
        'latitude', geocode.latitude,
        'longitude', geocode.longitude
      ) AS json_build_object
      FROM geocode WHERE geocode.id = train.home_station_geocode_id
    ) AS home_station_geocode,
    train.combination_id,
    (
      SELECT COALESCE(array_agg(locomotive.uuid ORDER BY locomotive_ref.array_order_index), array[]::uuid[]) AS array_agg
      FROM locomotive
      JOIN unnest(train.locomotive_ids) WITH ORDINALITY
        AS locomotive_ref (id, array_order_index)
        ON locomotive.id = locomotive_ref.id
    ) AS locomotive_uuids,
    (
      SELECT COALESCE(array_agg(carriage.uuid ORDER BY carriage_ref.array_order_index), array[]::uuid[]) AS array_agg
      FROM carriage
      JOIN unnest(train.carriage_ids) WITH ORDINALITY
        AS carriage_ref (id, array_order_index)
        ON carriage.id = carriage_ref.id
    ) AS carriage_uuids,
    (
      SELECT COALESCE(array_agg(train_engineer.uuid ORDER BY train_engineer_ref.array_order_index), array[]::uuid[]) AS array_agg
      FROM train_engineer
      JOIN unnest(train.engineer_ids) WITH ORDINALITY
        AS train_engineer_ref (id, array_order_index)
        ON train_engineer.id = train_engineer_ref.id
    ) AS engineer_uuids,
    (
      SELECT train_engineer.uuid
      FROM train_engineer WHERE train_engineer.id = train.lead_engineer_id
    ) AS lead_engineer_uuid,
    train.status
  FROM view_train_current AS train
  WHERE train.id = :id;
\`;

export const findById = async ({
  dbConnection,
  id,
}: {
  dbConnection: DatabaseConnection;
  id: number;
}): Promise<HasMetadata<Train> | null> => {
  const results = await sqlQueryFindTrainById({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      id,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "trainDao/findById.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { Train } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindTrainByUnique } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_train_by_unique
  SELECT
    train.id,
    train.uuid,
    (
      SELECT json_build_object(
        'id', geocode.id,
        'latitude', geocode.latitude,
        'longitude', geocode.longitude
      ) AS json_build_object
      FROM geocode WHERE geocode.id = train.home_station_geocode_id
    ) AS home_station_geocode,
    train.combination_id,
    (
      SELECT COALESCE(array_agg(locomotive.uuid ORDER BY locomotive_ref.array_order_index), array[]::uuid[]) AS array_agg
      FROM locomotive
      JOIN unnest(train.locomotive_ids) WITH ORDINALITY
        AS locomotive_ref (id, array_order_index)
        ON locomotive.id = locomotive_ref.id
    ) AS locomotive_uuids,
    (
      SELECT COALESCE(array_agg(carriage.uuid ORDER BY carriage_ref.array_order_index), array[]::uuid[]) AS array_agg
      FROM carriage
      JOIN unnest(train.carriage_ids) WITH ORDINALITY
        AS carriage_ref (id, array_order_index)
        ON carriage.id = carriage_ref.id
    ) AS carriage_uuids,
    (
      SELECT COALESCE(array_agg(train_engineer.uuid ORDER BY train_engineer_ref.array_order_index), array[]::uuid[]) AS array_agg
      FROM train_engineer
      JOIN unnest(train.engineer_ids) WITH ORDINALITY
        AS train_engineer_ref (id, array_order_index)
        ON train_engineer.id = train_engineer_ref.id
    ) AS engineer_uuids,
    (
      SELECT train_engineer.uuid
      FROM train_engineer WHERE train_engineer.id = train.lead_engineer_id
    ) AS lead_engineer_uuid,
    train.status
  FROM view_train_current AS train
  WHERE 1=1
    AND train.combination_id = :combinationId;
\`;

export const findByUnique = async ({
  dbConnection,
  combinationId,
}: {
  dbConnection: DatabaseConnection;
  combinationId: string;
}): Promise<HasMetadata<Train> | null> => {
  const results = await sqlQueryFindTrainByUnique({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      combinationId,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "trainDao/findByUnique.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { Train } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindTrainByUuid } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_train_by_uuid
  SELECT
    train.id,
    train.uuid,
    (
      SELECT json_build_object(
        'id', geocode.id,
        'latitude', geocode.latitude,
        'longitude', geocode.longitude
      ) AS json_build_object
      FROM geocode WHERE geocode.id = train.home_station_geocode_id
    ) AS home_station_geocode,
    train.combination_id,
    (
      SELECT COALESCE(array_agg(locomotive.uuid ORDER BY locomotive_ref.array_order_index), array[]::uuid[]) AS array_agg
      FROM locomotive
      JOIN unnest(train.locomotive_ids) WITH ORDINALITY
        AS locomotive_ref (id, array_order_index)
        ON locomotive.id = locomotive_ref.id
    ) AS locomotive_uuids,
    (
      SELECT COALESCE(array_agg(carriage.uuid ORDER BY carriage_ref.array_order_index), array[]::uuid[]) AS array_agg
      FROM carriage
      JOIN unnest(train.carriage_ids) WITH ORDINALITY
        AS carriage_ref (id, array_order_index)
        ON carriage.id = carriage_ref.id
    ) AS carriage_uuids,
    (
      SELECT COALESCE(array_agg(train_engineer.uuid ORDER BY train_engineer_ref.array_order_index), array[]::uuid[]) AS array_agg
      FROM train_engineer
      JOIN unnest(train.engineer_ids) WITH ORDINALITY
        AS train_engineer_ref (id, array_order_index)
        ON train_engineer.id = train_engineer_ref.id
    ) AS engineer_uuids,
    (
      SELECT train_engineer.uuid
      FROM train_engineer WHERE train_engineer.id = train.lead_engineer_id
    ) AS lead_engineer_uuid,
    train.status
  FROM view_train_current AS train
  WHERE train.uuid = :uuid;
\`;

export const findByUuid = async ({
  dbConnection,
  uuid,
}: {
  dbConnection: DatabaseConnection;
  uuid: string;
}): Promise<HasMetadata<Train> | null> => {
  const results = await sqlQueryFindTrainByUuid({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      uuid,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "trainDao/findByUuid.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { Train } from '$PATH_TO_DOMAIN_OBJECT';
import { log } from '$PATH_TO_LOG_OBJECT';
import { sqlQueryUpsertTrain } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { geocodeDao } from '../geocodeDao';

export const sql = \`
  -- query_name = upsert_train
  SELECT
    dgv.id, dgv.uuid
  FROM upsert_train(
    :homeStationGeocodeId,
    :combinationId,
    (
      SELECT COALESCE(array_agg(locomotive.id ORDER BY locomotive_ref.array_order_index), array[]::bigint[]) AS array_agg
      FROM locomotive
      JOIN unnest(:locomotiveUuids::uuid[]) WITH ORDINALITY
        AS locomotive_ref (uuid, array_order_index)
        ON locomotive.uuid = locomotive_ref.uuid
    ),
    (
      SELECT COALESCE(array_agg(carriage.id ORDER BY carriage_ref.array_order_index), array[]::bigint[]) AS array_agg
      FROM carriage
      JOIN unnest(:carriageUuids::uuid[]) WITH ORDINALITY
        AS carriage_ref (uuid, array_order_index)
        ON carriage.uuid = carriage_ref.uuid
    ),
    (
      SELECT COALESCE(array_agg(train_engineer.id ORDER BY train_engineer_ref.array_order_index), array[]::bigint[]) AS array_agg
      FROM train_engineer
      JOIN unnest(:engineerUuids::uuid[]) WITH ORDINALITY
        AS train_engineer_ref (uuid, array_order_index)
        ON train_engineer.uuid = train_engineer_ref.uuid
    ),
    (SELECT id FROM train_engineer WHERE train_engineer.uuid = :leadEngineerUuid),
    :status
  ) as dgv;
\`;

export const upsert = async ({
  dbConnection,
  train,
}: {
  dbConnection: DatabaseConnection;
  train: Train;
}): Promise<HasMetadata<Train>> => {
  const results = await sqlQueryUpsertTrain({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      homeStationGeocodeId: train.homeStationGeocode.id ? train.homeStationGeocode.id : (await geocodeDao.upsert({ dbConnection, geocode: train.homeStationGeocode })).id,
      combinationId: train.combinationId,
      locomotiveUuids: train.locomotiveUuids,
      carriageUuids: train.carriageUuids,
      engineerUuids: train.engineerUuids,
      leadEngineerUuid: train.leadEngineerUuid,
      status: train.status,
    },
  });
  const { id, uuid } = results[0]; // grab the db generated values
  return new Train({ ...train, id, uuid }) as HasMetadata<Train>;
};",
    "relpath": "trainDao/upsert.ts",
  },
  GeneratedCodeFile {
    "content": "import { findById } from './findById';
import { findByUnique } from './findByUnique';
import { findByUuid } from './findByUuid';
import { upsert } from './upsert';

export const locomotiveDao = {
  findById,
  findByUnique,
  findByUuid,
  upsert,
};",
    "relpath": "locomotiveDao/index.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { Locomotive } from '$PATH_TO_DOMAIN_OBJECT';
import { SqlQueryFindLocomotiveByIdOutput } from '$PATH_TO_GENERATED_SQL_TYPES';

export const castFromDatabaseObject = (
  dbObject: SqlQueryFindLocomotiveByIdOutput,
): HasMetadata<Locomotive> =>
  new Locomotive({
    id: dbObject.id,
    uuid: dbObject.uuid,
    createdAt: dbObject.created_at,
    effectiveAt: dbObject.effective_at,
    updatedAt: dbObject.updated_at,
    ein: dbObject.ein,
    fuel: dbObject.fuel as Locomotive['fuel'],
    capacity: dbObject.capacity,
    milage: dbObject.milage,
  }) as HasMetadata<Locomotive>;",
    "relpath": "locomotiveDao/castFromDatabaseObject.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { Locomotive } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindLocomotiveById } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_locomotive_by_id
  SELECT
    locomotive.id,
    locomotive.uuid,
    locomotive.created_at,
    locomotive.effective_at,
    locomotive.updated_at,
    locomotive.ein,
    locomotive.fuel,
    locomotive.capacity,
    locomotive.milage
  FROM view_locomotive_current AS locomotive
  WHERE locomotive.id = :id;
\`;

export const findById = async ({
  dbConnection,
  id,
}: {
  dbConnection: DatabaseConnection;
  id: number;
}): Promise<HasMetadata<Locomotive> | null> => {
  const results = await sqlQueryFindLocomotiveById({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      id,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "locomotiveDao/findById.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { Locomotive } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindLocomotiveByUnique } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_locomotive_by_unique
  SELECT
    locomotive.id,
    locomotive.uuid,
    locomotive.created_at,
    locomotive.effective_at,
    locomotive.updated_at,
    locomotive.ein,
    locomotive.fuel,
    locomotive.capacity,
    locomotive.milage
  FROM view_locomotive_current AS locomotive
  WHERE 1=1
    AND locomotive.ein = :ein;
\`;

export const findByUnique = async ({
  dbConnection,
  ein,
}: {
  dbConnection: DatabaseConnection;
  ein: string;
}): Promise<HasMetadata<Locomotive> | null> => {
  const results = await sqlQueryFindLocomotiveByUnique({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      ein,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "locomotiveDao/findByUnique.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { Locomotive } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindLocomotiveByUuid } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_locomotive_by_uuid
  SELECT
    locomotive.id,
    locomotive.uuid,
    locomotive.created_at,
    locomotive.effective_at,
    locomotive.updated_at,
    locomotive.ein,
    locomotive.fuel,
    locomotive.capacity,
    locomotive.milage
  FROM view_locomotive_current AS locomotive
  WHERE locomotive.uuid = :uuid;
\`;

export const findByUuid = async ({
  dbConnection,
  uuid,
}: {
  dbConnection: DatabaseConnection;
  uuid: string;
}): Promise<HasMetadata<Locomotive> | null> => {
  const results = await sqlQueryFindLocomotiveByUuid({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      uuid,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "locomotiveDao/findByUuid.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { Locomotive } from '$PATH_TO_DOMAIN_OBJECT';
import { log } from '$PATH_TO_LOG_OBJECT';
import { sqlQueryUpsertLocomotive } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';

export const sql = \`
  -- query_name = upsert_locomotive
  SELECT
    dgv.id, dgv.uuid, dgv.created_at, dgv.effective_at, dgv.updated_at
  FROM upsert_locomotive(
    :ein,
    :fuel,
    :capacity,
    :milage
  ) as dgv;
\`;

export const upsert = async ({
  dbConnection,
  locomotive,
}: {
  dbConnection: DatabaseConnection;
  locomotive: Locomotive;
}): Promise<HasMetadata<Locomotive>> => {
  const results = await sqlQueryUpsertLocomotive({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      ein: locomotive.ein,
      fuel: locomotive.fuel,
      capacity: locomotive.capacity,
      milage: locomotive.milage,
    },
  });
  const { id, uuid, created_at: createdAt, effective_at: effectiveAt, updated_at: updatedAt } = results[0]; // grab the db generated values
  return new Locomotive({ ...locomotive, id, uuid, createdAt, effectiveAt, updatedAt }) as HasMetadata<Locomotive>;
};",
    "relpath": "locomotiveDao/upsert.ts",
  },
  GeneratedCodeFile {
    "content": "import { findById } from './findById';
import { findByUnique } from './findByUnique';
import { upsert } from './upsert';

export const trainLocatedEventDao = {
  findById,
  findByUnique,
  upsert,
};",
    "relpath": "trainLocatedEventDao/index.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { TrainLocatedEvent } from '$PATH_TO_DOMAIN_OBJECT';
import { SqlQueryFindGeocodeByIdOutput, SqlQueryFindTrainLocatedEventByIdOutput } from '$PATH_TO_GENERATED_SQL_TYPES';
import { castFromDatabaseObject as castGeocodeFromDatabaseObject } from '../geocodeDao/castFromDatabaseObject';

export const castFromDatabaseObject = (
  dbObject: SqlQueryFindTrainLocatedEventByIdOutput,
): HasMetadata<TrainLocatedEvent> =>
  new TrainLocatedEvent({
    id: dbObject.id,
    trainUuid: dbObject.train_uuid,
    occurredAt: dbObject.occurred_at,
    geocode: castGeocodeFromDatabaseObject(dbObject.geocode as SqlQueryFindGeocodeByIdOutput),
  }) as HasMetadata<TrainLocatedEvent>;",
    "relpath": "trainLocatedEventDao/castFromDatabaseObject.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { TrainLocatedEvent } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindTrainLocatedEventById } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_train_located_event_by_id
  SELECT
    train_located_event.id,
    (
      SELECT train.uuid
      FROM train WHERE train.id = train_located_event.train_id
    ) AS train_uuid,
    train_located_event.occurred_at,
    (
      SELECT json_build_object(
        'id', geocode.id,
        'latitude', geocode.latitude,
        'longitude', geocode.longitude
      ) AS json_build_object
      FROM geocode WHERE geocode.id = train_located_event.geocode_id
    ) AS geocode
  FROM train_located_event
  WHERE train_located_event.id = :id;
\`;

export const findById = async ({
  dbConnection,
  id,
}: {
  dbConnection: DatabaseConnection;
  id: number;
}): Promise<HasMetadata<TrainLocatedEvent> | null> => {
  const results = await sqlQueryFindTrainLocatedEventById({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      id,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "trainLocatedEventDao/findById.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { TrainLocatedEvent } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindTrainLocatedEventByUnique } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_train_located_event_by_unique
  SELECT
    train_located_event.id,
    (
      SELECT train.uuid
      FROM train WHERE train.id = train_located_event.train_id
    ) AS train_uuid,
    train_located_event.occurred_at,
    (
      SELECT json_build_object(
        'id', geocode.id,
        'latitude', geocode.latitude,
        'longitude', geocode.longitude
      ) AS json_build_object
      FROM geocode WHERE geocode.id = train_located_event.geocode_id
    ) AS geocode
  FROM train_located_event
  WHERE 1=1
    AND train_located_event.train_id = (SELECT id FROM train WHERE train.uuid = :trainUuid)
    AND train_located_event.occurred_at = :occurredAt;
\`;

export const findByUnique = async ({
  dbConnection,
  trainUuid,
  occurredAt,
}: {
  dbConnection: DatabaseConnection;
  trainUuid: string;
  occurredAt: string;
}): Promise<HasMetadata<TrainLocatedEvent> | null> => {
  const results = await sqlQueryFindTrainLocatedEventByUnique({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      trainUuid,
      occurredAt,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "trainLocatedEventDao/findByUnique.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { TrainLocatedEvent } from '$PATH_TO_DOMAIN_OBJECT';
import { log } from '$PATH_TO_LOG_OBJECT';
import { sqlQueryUpsertTrainLocatedEvent } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { geocodeDao } from '../geocodeDao';

export const sql = \`
  -- query_name = upsert_train_located_event
  SELECT
    dgv.id
  FROM upsert_train_located_event(
    (SELECT id FROM train WHERE train.uuid = :trainUuid),
    :occurredAt,
    :geocodeId
  ) as dgv;
\`;

export const upsert = async ({
  dbConnection,
  trainLocatedEvent,
}: {
  dbConnection: DatabaseConnection;
  trainLocatedEvent: TrainLocatedEvent;
}): Promise<HasMetadata<TrainLocatedEvent>> => {
  const results = await sqlQueryUpsertTrainLocatedEvent({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      trainUuid: trainLocatedEvent.trainUuid,
      occurredAt: trainLocatedEvent.occurredAt,
      geocodeId: trainLocatedEvent.geocode.id ? trainLocatedEvent.geocode.id : (await geocodeDao.upsert({ dbConnection, geocode: trainLocatedEvent.geocode })).id,
    },
  });
  const { id } = results[0]; // grab the db generated values
  return new TrainLocatedEvent({ ...trainLocatedEvent, id }) as HasMetadata<TrainLocatedEvent>;
};",
    "relpath": "trainLocatedEventDao/upsert.ts",
  },
  GeneratedCodeFile {
    "content": "import { findById } from './findById';
import { findByUnique } from './findByUnique';
import { findByUuid } from './findByUuid';
import { upsert } from './upsert';

export const trainStationDao = {
  findById,
  findByUnique,
  findByUuid,
  upsert,
};",
    "relpath": "trainStationDao/index.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { TrainStation } from '$PATH_TO_DOMAIN_OBJECT';
import { SqlQueryFindGeocodeByIdOutput, SqlQueryFindTrainStationByIdOutput } from '$PATH_TO_GENERATED_SQL_TYPES';
import { castFromDatabaseObject as castGeocodeFromDatabaseObject } from '../geocodeDao/castFromDatabaseObject';

export const castFromDatabaseObject = (
  dbObject: SqlQueryFindTrainStationByIdOutput,
): HasMetadata<TrainStation> =>
  new TrainStation({
    id: dbObject.id,
    uuid: dbObject.uuid,
    geocode: castGeocodeFromDatabaseObject(dbObject.geocode as SqlQueryFindGeocodeByIdOutput),
    name: dbObject.name,
  }) as HasMetadata<TrainStation>;",
    "relpath": "trainStationDao/castFromDatabaseObject.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { TrainStation } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindTrainStationById } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_train_station_by_id
  SELECT
    train_station.id,
    train_station.uuid,
    (
      SELECT json_build_object(
        'id', geocode.id,
        'latitude', geocode.latitude,
        'longitude', geocode.longitude
      ) AS json_build_object
      FROM geocode WHERE geocode.id = train_station.geocode_id
    ) AS geocode,
    train_station.name
  FROM view_train_station_current AS train_station
  WHERE train_station.id = :id;
\`;

export const findById = async ({
  dbConnection,
  id,
}: {
  dbConnection: DatabaseConnection;
  id: number;
}): Promise<HasMetadata<TrainStation> | null> => {
  const results = await sqlQueryFindTrainStationById({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      id,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "trainStationDao/findById.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasId, HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { Geocode, TrainStation } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindTrainStationByUnique } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_train_station_by_unique
  SELECT
    train_station.id,
    train_station.uuid,
    (
      SELECT json_build_object(
        'id', geocode.id,
        'latitude', geocode.latitude,
        'longitude', geocode.longitude
      ) AS json_build_object
      FROM geocode WHERE geocode.id = train_station.geocode_id
    ) AS geocode,
    train_station.name
  FROM view_train_station_current AS train_station
  WHERE 1=1
    AND train_station.geocode_id = :geocodeId;
\`;

export const findByUnique = async ({
  dbConnection,
  geocode,
}: {
  dbConnection: DatabaseConnection;
  geocode: HasId<Geocode>;
}): Promise<HasMetadata<TrainStation> | null> => {
  const results = await sqlQueryFindTrainStationByUnique({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      geocodeId: geocode.id,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "trainStationDao/findByUnique.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { TrainStation } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindTrainStationByUuid } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_train_station_by_uuid
  SELECT
    train_station.id,
    train_station.uuid,
    (
      SELECT json_build_object(
        'id', geocode.id,
        'latitude', geocode.latitude,
        'longitude', geocode.longitude
      ) AS json_build_object
      FROM geocode WHERE geocode.id = train_station.geocode_id
    ) AS geocode,
    train_station.name
  FROM view_train_station_current AS train_station
  WHERE train_station.uuid = :uuid;
\`;

export const findByUuid = async ({
  dbConnection,
  uuid,
}: {
  dbConnection: DatabaseConnection;
  uuid: string;
}): Promise<HasMetadata<TrainStation> | null> => {
  const results = await sqlQueryFindTrainStationByUuid({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      uuid,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "trainStationDao/findByUuid.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { TrainStation } from '$PATH_TO_DOMAIN_OBJECT';
import { log } from '$PATH_TO_LOG_OBJECT';
import { sqlQueryUpsertTrainStation } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { geocodeDao } from '../geocodeDao';

export const sql = \`
  -- query_name = upsert_train_station
  SELECT
    dgv.id, dgv.uuid
  FROM upsert_train_station(
    :geocodeId,
    :name
  ) as dgv;
\`;

export const upsert = async ({
  dbConnection,
  trainStation,
}: {
  dbConnection: DatabaseConnection;
  trainStation: TrainStation;
}): Promise<HasMetadata<TrainStation>> => {
  const results = await sqlQueryUpsertTrainStation({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      geocodeId: trainStation.geocode.id ? trainStation.geocode.id : (await geocodeDao.upsert({ dbConnection, geocode: trainStation.geocode })).id,
      name: trainStation.name,
    },
  });
  const { id, uuid } = results[0]; // grab the db generated values
  return new TrainStation({ ...trainStation, id, uuid }) as HasMetadata<TrainStation>;
};",
    "relpath": "trainStationDao/upsert.ts",
  },
  GeneratedCodeFile {
    "content": "import { findById } from './findById';
import { findByUnique } from './findByUnique';
import { upsert } from './upsert';

export const priceDao = {
  findById,
  findByUnique,
  upsert,
};",
    "relpath": "priceDao/index.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { Price } from '$PATH_TO_DOMAIN_OBJECT';
import { SqlQueryFindPriceByIdOutput } from '$PATH_TO_GENERATED_SQL_TYPES';

export const castFromDatabaseObject = (
  dbObject: SqlQueryFindPriceByIdOutput,
): HasMetadata<Price> =>
  new Price({
    id: dbObject.id,
    amount: dbObject.amount,
    currency: dbObject.currency as Price['currency'],
  }) as HasMetadata<Price>;",
    "relpath": "priceDao/castFromDatabaseObject.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { Price } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindPriceById } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_price_by_id
  SELECT
    price.id,
    price.amount,
    price.currency
  FROM price
  WHERE price.id = :id;
\`;

export const findById = async ({
  dbConnection,
  id,
}: {
  dbConnection: DatabaseConnection;
  id: number;
}): Promise<HasMetadata<Price> | null> => {
  const results = await sqlQueryFindPriceById({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      id,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "priceDao/findById.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { Price } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindPriceByUnique } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_price_by_unique
  SELECT
    price.id,
    price.amount,
    price.currency
  FROM price
  WHERE 1=1
    AND price.amount = :amount
    AND price.currency = :currency;
\`;

export const findByUnique = async ({
  dbConnection,
  amount,
  currency,
}: {
  dbConnection: DatabaseConnection;
  amount: number;
  currency: Price['currency'];
}): Promise<HasMetadata<Price> | null> => {
  const results = await sqlQueryFindPriceByUnique({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      amount,
      currency,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "priceDao/findByUnique.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { Price } from '$PATH_TO_DOMAIN_OBJECT';
import { log } from '$PATH_TO_LOG_OBJECT';
import { sqlQueryUpsertPrice } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';

export const sql = \`
  -- query_name = upsert_price
  SELECT
    dgv.id
  FROM upsert_price(
    :amount,
    :currency
  ) as dgv;
\`;

export const upsert = async ({
  dbConnection,
  price,
}: {
  dbConnection: DatabaseConnection;
  price: Price;
}): Promise<HasMetadata<Price>> => {
  const results = await sqlQueryUpsertPrice({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      amount: price.amount,
      currency: price.currency,
    },
  });
  const { id } = results[0]; // grab the db generated values
  return new Price({ ...price, id }) as HasMetadata<Price>;
};",
    "relpath": "priceDao/upsert.ts",
  },
  GeneratedCodeFile {
    "content": "import { findById } from './findById';
import { findByUnique } from './findByUnique';
import { upsert } from './upsert';

export const invoiceLineItemDao = {
  findById,
  findByUnique,
  upsert,
};",
    "relpath": "invoiceLineItemDao/index.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { InvoiceLineItem } from '$PATH_TO_DOMAIN_OBJECT';
import { SqlQueryFindInvoiceLineItemByIdOutput, SqlQueryFindPriceByIdOutput } from '$PATH_TO_GENERATED_SQL_TYPES';
import { castFromDatabaseObject as castPriceFromDatabaseObject } from '../priceDao/castFromDatabaseObject';

export const castFromDatabaseObject = (
  dbObject: SqlQueryFindInvoiceLineItemByIdOutput,
): HasMetadata<InvoiceLineItem> =>
  new InvoiceLineItem({
    id: dbObject.id,
    price: castPriceFromDatabaseObject(dbObject.price as SqlQueryFindPriceByIdOutput),
    title: dbObject.title,
    explanation: dbObject.explanation,
  }) as HasMetadata<InvoiceLineItem>;",
    "relpath": "invoiceLineItemDao/castFromDatabaseObject.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { InvoiceLineItem } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindInvoiceLineItemById } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_invoice_line_item_by_id
  SELECT
    invoice_line_item.id,
    (
      SELECT json_build_object(
        'id', price.id,
        'amount', price.amount,
        'currency', price.currency
      ) AS json_build_object
      FROM price WHERE price.id = invoice_line_item.price_id
    ) AS price,
    invoice_line_item.title,
    invoice_line_item.explanation
  FROM invoice_line_item
  WHERE invoice_line_item.id = :id;
\`;

export const findById = async ({
  dbConnection,
  id,
}: {
  dbConnection: DatabaseConnection;
  id: number;
}): Promise<HasMetadata<InvoiceLineItem> | null> => {
  const results = await sqlQueryFindInvoiceLineItemById({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      id,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "invoiceLineItemDao/findById.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasId, HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { InvoiceLineItem, Price } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindInvoiceLineItemByUnique } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_invoice_line_item_by_unique
  SELECT
    invoice_line_item.id,
    (
      SELECT json_build_object(
        'id', price.id,
        'amount', price.amount,
        'currency', price.currency
      ) AS json_build_object
      FROM price WHERE price.id = invoice_line_item.price_id
    ) AS price,
    invoice_line_item.title,
    invoice_line_item.explanation
  FROM invoice_line_item
  WHERE 1=1
    AND invoice_line_item.price_id = :priceId
    AND invoice_line_item.title = :title
    AND invoice_line_item.explanation = :explanation;
\`;

export const findByUnique = async ({
  dbConnection,
  price,
  title,
  explanation,
}: {
  dbConnection: DatabaseConnection;
  price: HasId<Price>;
  title: string;
  explanation: string;
}): Promise<HasMetadata<InvoiceLineItem> | null> => {
  const results = await sqlQueryFindInvoiceLineItemByUnique({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      priceId: price.id,
      title,
      explanation,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "invoiceLineItemDao/findByUnique.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { InvoiceLineItem } from '$PATH_TO_DOMAIN_OBJECT';
import { log } from '$PATH_TO_LOG_OBJECT';
import { sqlQueryUpsertInvoiceLineItem } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { priceDao } from '../priceDao';

export const sql = \`
  -- query_name = upsert_invoice_line_item
  SELECT
    dgv.id
  FROM upsert_invoice_line_item(
    :priceId,
    :title,
    :explanation
  ) as dgv;
\`;

export const upsert = async ({
  dbConnection,
  invoiceLineItem,
}: {
  dbConnection: DatabaseConnection;
  invoiceLineItem: InvoiceLineItem;
}): Promise<HasMetadata<InvoiceLineItem>> => {
  const results = await sqlQueryUpsertInvoiceLineItem({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      priceId: invoiceLineItem.price.id ? invoiceLineItem.price.id : (await priceDao.upsert({ dbConnection, price: invoiceLineItem.price })).id,
      title: invoiceLineItem.title,
      explanation: invoiceLineItem.explanation,
    },
  });
  const { id } = results[0]; // grab the db generated values
  return new InvoiceLineItem({ ...invoiceLineItem, id }) as HasMetadata<InvoiceLineItem>;
};",
    "relpath": "invoiceLineItemDao/upsert.ts",
  },
  GeneratedCodeFile {
    "content": "import { findById } from './findById';
import { findByUnique } from './findByUnique';
import { findByUuid } from './findByUuid';
import { upsert } from './upsert';

export const invoiceDao = {
  findById,
  findByUnique,
  findByUuid,
  upsert,
};",
    "relpath": "invoiceDao/index.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { Invoice } from '$PATH_TO_DOMAIN_OBJECT';
import { SqlQueryFindInvoiceByIdOutput, SqlQueryFindInvoiceLineItemByIdOutput, SqlQueryFindPriceByIdOutput } from '$PATH_TO_GENERATED_SQL_TYPES';
import { castFromDatabaseObject as castInvoiceLineItemFromDatabaseObject } from '../invoiceLineItemDao/castFromDatabaseObject';
import { castFromDatabaseObject as castPriceFromDatabaseObject } from '../priceDao/castFromDatabaseObject';

export const castFromDatabaseObject = (
  dbObject: SqlQueryFindInvoiceByIdOutput,
): HasMetadata<Invoice> =>
  new Invoice({
    id: dbObject.id,
    uuid: dbObject.uuid,
    externalId: dbObject.external_id,
    items: (dbObject.items as SqlQueryFindInvoiceLineItemByIdOutput[]).map(castInvoiceLineItemFromDatabaseObject),
    totalPrice: castPriceFromDatabaseObject(dbObject.total_price as SqlQueryFindPriceByIdOutput),
    status: dbObject.status as Invoice['status'],
  }) as HasMetadata<Invoice>;",
    "relpath": "invoiceDao/castFromDatabaseObject.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { Invoice } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindInvoiceById } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_invoice_by_id
  SELECT
    invoice.id,
    invoice.uuid,
    invoice.external_id,
    (
      SELECT COALESCE(
        json_agg(
          json_build_object(
            'id', invoice_line_item.id,
            'price', (
              SELECT json_build_object(
                'id', price.id,
                'amount', price.amount,
                'currency', price.currency
              ) AS json_build_object
              FROM price WHERE price.id = invoice_line_item.price_id
            ),
            'title', invoice_line_item.title,
            'explanation', invoice_line_item.explanation
          )
          ORDER BY invoice_line_item_ref.array_order_index
        ),
        '[]'::json
      ) AS json_agg
      FROM invoice_line_item
      JOIN unnest(invoice.item_ids) WITH ORDINALITY
        AS invoice_line_item_ref (id, array_order_index)
        ON invoice_line_item.id = invoice_line_item_ref.id
    ) AS items,
    (
      SELECT json_build_object(
        'id', price.id,
        'amount', price.amount,
        'currency', price.currency
      ) AS json_build_object
      FROM price WHERE price.id = invoice.total_price_id
    ) AS total_price,
    invoice.status
  FROM view_invoice_current AS invoice
  WHERE invoice.id = :id;
\`;

export const findById = async ({
  dbConnection,
  id,
}: {
  dbConnection: DatabaseConnection;
  id: number;
}): Promise<HasMetadata<Invoice> | null> => {
  const results = await sqlQueryFindInvoiceById({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      id,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "invoiceDao/findById.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { Invoice } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindInvoiceByUnique } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_invoice_by_unique
  SELECT
    invoice.id,
    invoice.uuid,
    invoice.external_id,
    (
      SELECT COALESCE(
        json_agg(
          json_build_object(
            'id', invoice_line_item.id,
            'price', (
              SELECT json_build_object(
                'id', price.id,
                'amount', price.amount,
                'currency', price.currency
              ) AS json_build_object
              FROM price WHERE price.id = invoice_line_item.price_id
            ),
            'title', invoice_line_item.title,
            'explanation', invoice_line_item.explanation
          )
          ORDER BY invoice_line_item_ref.array_order_index
        ),
        '[]'::json
      ) AS json_agg
      FROM invoice_line_item
      JOIN unnest(invoice.item_ids) WITH ORDINALITY
        AS invoice_line_item_ref (id, array_order_index)
        ON invoice_line_item.id = invoice_line_item_ref.id
    ) AS items,
    (
      SELECT json_build_object(
        'id', price.id,
        'amount', price.amount,
        'currency', price.currency
      ) AS json_build_object
      FROM price WHERE price.id = invoice.total_price_id
    ) AS total_price,
    invoice.status
  FROM view_invoice_current AS invoice
  WHERE 1=1
    AND invoice.external_id = :externalId;
\`;

export const findByUnique = async ({
  dbConnection,
  externalId,
}: {
  dbConnection: DatabaseConnection;
  externalId: string;
}): Promise<HasMetadata<Invoice> | null> => {
  const results = await sqlQueryFindInvoiceByUnique({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      externalId,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "invoiceDao/findByUnique.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { log } from '$PATH_TO_LOG_OBJECT';
import { Invoice } from '$PATH_TO_DOMAIN_OBJECT';
import { sqlQueryFindInvoiceByUuid } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { castFromDatabaseObject } from './castFromDatabaseObject';

export const sql = \`
  -- query_name = find_invoice_by_uuid
  SELECT
    invoice.id,
    invoice.uuid,
    invoice.external_id,
    (
      SELECT COALESCE(
        json_agg(
          json_build_object(
            'id', invoice_line_item.id,
            'price', (
              SELECT json_build_object(
                'id', price.id,
                'amount', price.amount,
                'currency', price.currency
              ) AS json_build_object
              FROM price WHERE price.id = invoice_line_item.price_id
            ),
            'title', invoice_line_item.title,
            'explanation', invoice_line_item.explanation
          )
          ORDER BY invoice_line_item_ref.array_order_index
        ),
        '[]'::json
      ) AS json_agg
      FROM invoice_line_item
      JOIN unnest(invoice.item_ids) WITH ORDINALITY
        AS invoice_line_item_ref (id, array_order_index)
        ON invoice_line_item.id = invoice_line_item_ref.id
    ) AS items,
    (
      SELECT json_build_object(
        'id', price.id,
        'amount', price.amount,
        'currency', price.currency
      ) AS json_build_object
      FROM price WHERE price.id = invoice.total_price_id
    ) AS total_price,
    invoice.status
  FROM view_invoice_current AS invoice
  WHERE invoice.uuid = :uuid;
\`;

export const findByUuid = async ({
  dbConnection,
  uuid,
}: {
  dbConnection: DatabaseConnection;
  uuid: string;
}): Promise<HasMetadata<Invoice> | null> => {
  const results = await sqlQueryFindInvoiceByUuid({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      uuid,
    },
  });
  const [dbObject, ...moreDbObjects] = results;
  if (moreDbObjects.length) throw new Error('expected only one db object for this query');
  if (!dbObject) return null;
  return castFromDatabaseObject(dbObject);
};",
    "relpath": "invoiceDao/findByUuid.ts",
  },
  GeneratedCodeFile {
    "content": "import { HasMetadata } from 'type-fns';

import { DatabaseConnection } from '$PATH_TO_DATABASE_CONNECTION';
import { Invoice } from '$PATH_TO_DOMAIN_OBJECT';
import { log } from '$PATH_TO_LOG_OBJECT';
import { sqlQueryUpsertInvoice } from '$PATH_TO_GENERATED_SQL_QUERY_FUNCTIONS';
import { invoiceLineItemDao } from '../invoiceLineItemDao';
import { priceDao } from '../priceDao';

export const sql = \`
  -- query_name = upsert_invoice
  SELECT
    dgv.id, dgv.uuid
  FROM upsert_invoice(
    :externalId,
    :itemIds,
    :totalPriceId,
    :status
  ) as dgv;
\`;

export const upsert = async ({
  dbConnection,
  invoice,
}: {
  dbConnection: DatabaseConnection;
  invoice: Invoice;
}): Promise<HasMetadata<Invoice>> => {
  const results = await sqlQueryUpsertInvoice({
    dbExecute: dbConnection.query,
    logDebug: log.debug,
    input: {
      externalId: invoice.externalId,
      itemIds: await Promise.all(invoice.items.map(async (invoiceLineItem) => invoiceLineItem.id ? invoiceLineItem.id : (await invoiceLineItemDao.upsert({ dbConnection, invoiceLineItem })).id)),
      totalPriceId: invoice.totalPrice.id ? invoice.totalPrice.id : (await priceDao.upsert({ dbConnection, price: invoice.totalPrice })).id,
      status: invoice.status,
    },
  });
  const { id, uuid } = results[0]; // grab the db generated values
  return new Invoice({ ...invoice, id, uuid }) as HasMetadata<Invoice>;
};",
    "relpath": "invoiceDao/upsert.ts",
  },
]
`;
